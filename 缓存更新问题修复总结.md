# 缓存更新问题修复总结

## 问题描述

用户报告了两个页面更新后 `LibraryAssetsTable` 没有及时刷新的问题：

### 问题 3：AssetDetail 页面创建 asset 后，LibraryAssetsTable 没有更新

**问题根源**：
- `assetDetail` 页面在创建 asset 时，只触发了 `assetCreated` 事件
- 虽然 `LibraryPage` 监听了该事件并调用 `queryClient.invalidateQueries()`
- 但是当用户从 `assetDetail` 页面导航回 `LibraryPage` 时，可能存在时序问题：
  - 事件触发后立即导航（500ms 延迟）
  - `LibraryPage` 的 invalidate 调用可能在组件重新挂载前被忽略
  - 导致返回 `LibraryPage` 时使用的是旧的缓存数据

**修复方案**：
在 `assetDetail` 页面创建 asset 时，直接调用 `queryClient.invalidateQueries()` 来确保 React Query 缓存被标记为过期。

### 问题 4：删除 predefine section 后，LibraryAssetsTable 没有更新

**问题根源**：
- `predefine` 页面在删除 section 或保存 schema 时，只触发了 `schemaUpdated` 事件
- 虽然 `LibraryPage` 监听了该事件并调用 `queryClient.invalidateQueries()`
- 但可能存在类似的时序问题，导致 cache invalidation 没有生效

**修复方案**：
在 `predefine` 页面删除 section 或保存 schema 时，直接调用 `queryClient.invalidateQueries()` 来确保缓存被标记为过期。

---

## 修复详情

### 1. AssetDetail 页面 (`src/app/(dashboard)/[projectId]/[libraryId]/[assetId]/page.tsx`)

#### 1.1 添加 React Query 依赖

```typescript
import { useQueryClient } from '@tanstack/react-query';
import { queryKeys } from '@/lib/utils/queryKeys';

export default function AssetPage() {
  const queryClient = useQueryClient();
  // ... other code
}
```

#### 1.2 在创建 asset 后直接 invalidate cache

```typescript
// 在 handleSave 函数中，创建新 asset 后
setValues({});
setNavigating(true);

// 修复：直接 invalidate React Query cache
queryClient.invalidateQueries({ queryKey: queryKeys.libraryAssets(libraryId) });
queryClient.invalidateQueries({ queryKey: queryKeys.librarySummary(libraryId) });

// 向后兼容：触发事件通知 Sidebar
window.dispatchEvent(new CustomEvent('assetCreated', {
  detail: { libraryId, assetId: newAssetId }
}));

// 导航到编辑页面
setTimeout(() => {
  router.push(`/${projectId}/${libraryId}/${newAssetId}`);
}, 500);
```

**关键改进**：
- 在触发事件之前直接调用 `invalidateQueries`，确保缓存被标记为过期
- 这样当用户导航回 `LibraryPage` 时，React Query 会自动 refetch 最新数据
- 保留了事件触发，确保 Sidebar 等其他组件也能收到通知

---

### 2. Predefine 页面 (`src/app/(dashboard)/[projectId]/[libraryId]/predefine/page.tsx`)

#### 2.1 添加 React Query 依赖

```typescript
import { useQueryClient } from '@tanstack/react-query';
import { queryKeys } from '@/lib/utils/queryKeys';

function PredefinePageContent() {
  const queryClient = useQueryClient();
  // ... other code
}
```

#### 2.2 在保存 schema 后直接 invalidate cache

```typescript
// 在 saveSchema 函数中
try {
  await saveSchemaIncremental(supabase, libraryId, finalSections);

  message.success('Saved successfully, loading...');
  
  // 修复：直接 invalidate React Query cache
  queryClient.invalidateQueries({ queryKey: queryKeys.librarySchema(libraryId) });
  queryClient.invalidateQueries({ queryKey: queryKeys.libraryAssets(libraryId) });
  queryClient.invalidateQueries({ queryKey: queryKeys.librarySummary(libraryId) });
  
  // 向后兼容：触发事件
  window.dispatchEvent(new CustomEvent('schemaUpdated', {
    detail: { libraryId }
  }));

  // ... rest of the code
}
```

#### 2.3 在删除 section 后直接 invalidate cache

```typescript
// 在 handleDeleteSection 函数中
if (delError) throw delError;

message.success(`Section "${sectionToDelete.name}" deleted successfully`);

// Invalidate cache before reloading to ensure fresh data
const { globalRequestCache } = await import('@/lib/hooks/useRequestCache');
globalRequestCache.invalidate(`field-definitions:${libraryId}`);

// 修复：直接 invalidate React Query cache
queryClient.invalidateQueries({ queryKey: queryKeys.librarySchema(libraryId) });
queryClient.invalidateQueries({ queryKey: queryKeys.libraryAssets(libraryId) });
queryClient.invalidateQueries({ queryKey: queryKeys.librarySummary(libraryId) });

// 向后兼容：触发事件
window.dispatchEvent(new CustomEvent('schemaUpdated', {
  detail: { libraryId }
}));

// Reload to sync with database
const loadedSections = await reloadSections();
// ...
```

**关键改进**：
- 在保存 schema 或删除 section 时，直接调用 `invalidateQueries`
- invalidate 三个相关的 query keys：
  - `librarySchema`: 确保 schema 定义更新
  - `libraryAssets`: 确保 asset 数据更新（因为 schema 改变可能影响 asset 结构）
  - `librarySummary`: 确保 summary 统计数据更新
- 保留了事件触发，确保向后兼容

---

## 原理说明

### 为什么需要直接调用 invalidateQueries？

1. **时序问题**：
   - 当用户从 `AssetDetailPage` 创建 asset 后立即导航回 `LibraryPage`，可能存在以下时序：
     - `AssetDetailPage` 触发 `assetCreated` 事件
     - `AssetDetailPage` 导航到新的 asset 页面
     - 用户点击返回，导航回 `LibraryPage`
     - `LibraryPage` 重新挂载，但之前的 invalidate 可能已经被清理
   
2. **组件生命周期**：
   - 事件监听器是在 `useEffect` 中注册的
   - 如果组件在事件触发时还未挂载或已卸载，invalidate 调用可能不会生效
   - 直接在数据变更的地方调用 `invalidateQueries` 可以确保缓存立即被标记为过期

3. **React Query 的缓存机制**：
   - React Query 会跨组件共享缓存
   - `invalidateQueries` 会标记匹配的查询为"stale"（过期）
   - 当组件挂载并使用这些查询时，React Query 会自动 refetch
   - 这样即使组件在数据变更时还未挂载，也能获取到最新数据

### 为什么保留事件触发？

1. **向后兼容**：
   - 其他组件（如 Sidebar）可能仍在监听这些事件
   - 保留事件触发确保这些组件也能及时更新

2. **跨页面通信**：
   - 事件机制提供了一种简单的跨页面通信方式
   - 虽然 React Query 可以管理缓存，但事件可以触发其他 UI 更新（如显示通知）

---

## 测试验证

### 测试场景 1：创建 asset
1. 进入 `assetDetail` 页面（URL: `/project/library/new`）
2. 填写 asset 信息
3. 点击创建
4. 页面导航到新创建的 asset 详情页
5. 点击返回按钮，回到 `LibraryPage`
6. **预期结果**：LibraryAssetsTable 显示新创建的 asset

### 测试场景 2：删除 predefine section
1. 进入 `predefine` 页面
2. 选择一个 section
3. 点击删除
4. 确认删除
5. 页面重新加载 sections
6. 回到 `LibraryPage`
7. **预期结果**：LibraryAssetsTable 不再显示被删除 section 的列

### 测试场景 3：保存 predefine schema
1. 进入 `predefine` 页面
2. 修改某个 field 的配置（如改变 label）
3. 点击保存
4. 回到 `LibraryPage`
5. **预期结果**：LibraryAssetsTable 显示更新后的 field label

---

## 技术要点

### 1. React Query 的 invalidateQueries

```typescript
queryClient.invalidateQueries({ queryKey: queryKeys.libraryAssets(libraryId) });
```

这个调用会：
- 标记所有匹配 `queryKey` 的查询为"stale"
- 如果有组件正在使用这些查询，会立即触发 refetch
- 如果没有组件使用，下次使用时会自动 refetch

### 2. queryKeys 的设计

```typescript
export const queryKeys = {
  libraryAssets: (libraryId: string) => ['library', 'assets', libraryId],
  librarySchema: (libraryId: string) => ['library', 'schema', libraryId],
  librarySummary: (libraryId: string) => ['library', 'summary', libraryId],
  // ...
};
```

- 使用数组形式的 key，支持层级匹配
- 例如：`invalidateQueries({ queryKey: ['library', 'assets'] })` 会 invalidate 所有 library assets 的查询

### 3. 事件与 React Query 的配合

```typescript
// 1. 直接 invalidate cache（主要机制）
queryClient.invalidateQueries({ queryKey: queryKeys.libraryAssets(libraryId) });

// 2. 触发事件（向后兼容）
window.dispatchEvent(new CustomEvent('assetCreated', {
  detail: { libraryId, assetId: newAssetId }
}));
```

这种"双保险"机制确保：
- React Query 管理的组件能及时更新（通过 invalidate）
- 监听事件的组件也能收到通知（通过 event）

---

## 相关文件

### 修改的文件
1. `/home/a1136/Workspace/keco-studio/src/app/(dashboard)/[projectId]/[libraryId]/[assetId]/page.tsx`
2. `/home/a1136/Workspace/keco-studio/src/app/(dashboard)/[projectId]/[libraryId]/predefine/page.tsx`

### 相关文件（未修改）
1. `/home/a1136/Workspace/keco-studio/src/app/(dashboard)/[projectId]/[libraryId]/page.tsx` - LibraryPage（保留了事件监听器）
2. `/home/a1136/Workspace/keco-studio/src/components/libraries/LibraryAssetsTable.tsx` - LibraryAssetsTable 组件
3. `/home/a1136/Workspace/keco-studio/src/lib/utils/queryKeys.ts` - Query keys 定义

---

## 总结

这次修复通过在数据变更点直接调用 `queryClient.invalidateQueries()` 来解决缓存更新不及时的问题。关键改进：

1. **直接 invalidate**：在数据变更的地方直接标记缓存为过期，而不是依赖事件传播
2. **跨组件同步**：利用 React Query 的全局缓存机制，确保所有使用相同数据的组件都能获取最新数据
3. **向后兼容**：保留事件触发机制，确保其他监听事件的组件也能正常工作

通过这种方式，我们确保了数据的一致性和 UI 的实时更新，提升了用户体验。

