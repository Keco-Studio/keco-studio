# 验证缓存优化效果

## 测试步骤

### 1. 打开浏览器开发者工具
- 按 F12 或右键 → 检查
- 切换到 **Network（网络）** 标签页
- 勾选 **Preserve log（保留日志）**
- 点击 **Clear（清空）** 清除之前的记录

### 2. 测试 LibraryPage 的优化

#### 场景 A：编辑 Library 名称
1. 打开一个 Library 页面（例如：`/projectId/libraryId`）
2. 点击编辑按钮，修改 Library 名称
3. 保存修改

**预期结果**：
- ✅ **优化后**：只看到 1-2 个请求
  - 1 个 PUT/POST 请求（更新名称）
  - 1-2 个 GET 请求（只刷新 library 和 summary）
  - 总计约 2-3 个请求

- ❌ **优化前**：会看到 5-6 个请求
  - 1 个 PUT/POST 请求（更新名称）
  - 多个 GET 请求（重新获取 project、library、summary、schema、assets）
  
**网络请求对比**：
```
优化前（假设）：
POST /api/libraries/xxx/update
GET  /api/projects/xxx           ← 不必要
GET  /api/libraries/xxx
GET  /api/libraries/xxx/summary
GET  /api/libraries/xxx/schema   ← 不必要（schema 没变）
GET  /api/libraries/xxx/assets   ← 不必要（assets 没变）
总计：6 个请求

优化后：
POST /api/libraries/xxx/update
GET  /api/libraries/xxx          ← 只刷新改变的
GET  /api/libraries/xxx/summary  ← 只刷新改变的
总计：3 个请求 ✅ 减少 50%
```

#### 场景 B：创建/删除 Asset
1. 在 Library 页面创建或删除一个 Asset
2. 观察网络请求

**预期结果**：
- ✅ 只刷新 assets 列表和 summary
- ❌ 不会重新获取 library、schema 等未改变的数据

### 3. 测试 FolderPage 的优化

#### 场景：编辑 Library 名称（从 Folder 视图）
1. 打开一个 Folder 页面（`/projectId/folder/folderId`）
2. 编辑其中一个 Library 的名称
3. 保存修改

**预期结果**：
```
优化前：
POST /api/libraries/xxx/update
GET  /api/folders/xxx            ← 不必要（folder 没变）
GET  /api/libraries?folderId=xxx ← 必要
总计：3 个请求

优化后：
POST /api/libraries/xxx/update
GET  /api/libraries?folderId=xxx ← 只刷新 libraries
总计：2 个请求 ✅ 减少 33%
```

### 4. 测试 ProjectPage 的优化

#### 场景：更新 Project 名称
1. 在 Project 页面编辑项目名称
2. 观察网络请求

**预期结果**：
```
优化前：
POST /api/projects/xxx/update
GET  /api/projects/xxx
GET  /api/folders?projectId=xxx   ← 不必要
GET  /api/libraries?projectId=xxx ← 不必要
总计：4 个请求

优化后：
POST /api/projects/xxx/update
GET  /api/projects/xxx            ← 只刷新 project
总计：2 个请求 ✅ 减少 50%
```

## 性能对比表

| 操作 | 优化前请求数 | 优化后请求数 | 减少比例 |
|------|------------|------------|---------|
| 编辑 Library 名称 | 5-6 个 | 2-3 个 | 50-60% |
| 创建 Asset | 4-5 个 | 2-3 个 | 40-50% |
| 删除 Asset | 4-5 个 | 2-3 个 | 40-50% |
| 编辑 Folder 名称 | 3-4 个 | 2 个 | 40-50% |
| 编辑 Project 名称 | 4-5 个 | 2 个 | 50-60% |

## React Query DevTools 验证

### 安装 React Query DevTools
如果还没有安装，可以查看缓存状态：

1. 打开浏览器控制台（Console）
2. 输入以下命令查看缓存：
```javascript
// 查看当前所有缓存的查询
window.__REACT_QUERY_DEVTOOLS_GLOBAL_HOOK__?.queryClient?.getQueryCache()?.getAll()
```

### 观察缓存行为
编辑一个 Library 名称后，你应该看到：
- ✅ `['library', 'xxx']` 这个查询被标记为 `stale`（过期）并重新获取
- ✅ `['library', 'xxx', 'summary']` 被标记为 `stale` 并重新获取
- ✅ `['library', 'xxx', 'assets']` 保持 `fresh`（新鲜），不会重新获取
- ✅ `['library', 'xxx', 'schema']` 保持 `fresh`，不会重新获取

## 为什么可能感受不明显？

### 1. **网络速度快**
如果你的网络很快（本地开发或内网），减少 2-3 个请求可能只节省 100-300ms，不太明显。

### 2. **数据量小**
如果 assets 和 schema 数据量很小，重新获取也很快。

### 3. **已经有部分优化**
ProjectPage 在之前就已经优化过了（从代码看已经在用 React Query），所以效果不明显。

### 4. **缓存时间设置**
React Query 默认缓存 5 分钟，如果在这个时间内操作，本来就不会发请求。

## 如何让效果更明显？

### 方法 1：模拟慢网络
1. 打开 Chrome DevTools → Network
2. 选择 **Slow 3G** 或 **Fast 3G**
3. 再次测试编辑操作
4. 现在应该能明显感受到差异

### 方法 2：清除缓存测试
```javascript
// 在控制台运行，清除所有 React Query 缓存
queryClient.clear()
```
然后立即执行多个编辑操作，对比请求数量。

### 方法 3：查看具体的时间对比
```
优化前（慢网络）：
- 编辑名称 → 等待 2-3 秒（多个请求串行）

优化后（慢网络）：
- 编辑名称 → 等待 0.5-1 秒（只有必要的请求）
```

## 总结

这次优化的核心是：
1. ✅ **精确失效**：只刷新真正改变的数据
2. ✅ **减少请求**：从 4-6 个减少到 2-3 个
3. ✅ **保持缓存**：未改变的数据（schema、assets）继续使用缓存
4. ✅ **更快响应**：特别是在慢网络环境下效果明显

建议在 **慢网络** 或 **大数据量** 场景下测试，效果会更显著！

